# CCD Basic Study Guide

## 1.0 Cyberspace Operations Fundamentals

Training Resources and Technical References:

 - JP 3-12

### 1.1 Describe the mission of the following Cyber Mission Force (CMF) Elements:

 - Cyber National Mission Force (CNMF) - The CNMF conducts cyberspace operations to **defeat significant cyberspace threats** to the Department of Defense Information Network (DODIN) and, when ordered, to defeat significant cyberspace threats to the nation.
   - Comprised of various National Mission Teams (NMTs), national support teams, and national-level Cyber Protection Teams (CPTs).
   - Focused on **national-level threats**, often operating beyond DODIN to protect broader US interests.
   - Operates under USCYBERCOM authority.
 - Cyber Combat Mission Force (CCMF) - the CCMF conducts cyberspace operations to **support the missions, plans, and priorities** of geographic and functional Combatant Commanders (CCDRs).
   - Composed of various Combat Mission Teams (CMTs) and combat support teams.
   - These teams are typically assigned missions aligned with specific regional or functional combatant commands.
   - Supports **offensive cyberspace operations (OCO)** aligned with conventional military campaigns.
 - Cyber Protection Force (CPF) - The CPF is responsible for conducting cyberspace operations focused on the **internal protection** of the DODIN or other friendly cyberspace.
   - Comprised of Cyber Protection Teams (CPTs).
   - These teams are assigned to defend and secure specific systems, networks, and infrastructure from threats.
   - Plays a critical role in **Defensive Cyberspace Operations (DCO)** and maintaining cyber resilience.

### 1.2 Describe the mission of the following CMF teams:

 - Combat Mission Team (CMT)
   - **Mission**: Execute **offensive cyberspace operations (OCO)** in support of geographic and functional Combatant Commander (CCDR) objectives.
   - **Function**: Target adversary networks, systems, or capabilities to achieve combat effects.
   - **Alignment**: Part of the Cyber Combat Mission Force (CCMF).
 - National Mission Team (NMT)
   - **Mission**: Conduct cyberspace operations to **counter and defeat strategic-level threats** to national security.
   - **Function**: Focus on nation-state-level or otherwise significant threats that pose direct risks to the United States.
   - **Alignment**: Part of the Cyber National Mission Force (CNMF).
 - Combat Support Team (CST)
   - **Mission**: Provide **technical and operational support** to CMTs.
   - **Function**: Enable CMTs by supporting target development, access maintenance, tool deployment, and execution of operations.
   - **Alignment**: Part of the CCMF, they work directly alongside CMTs.
 - National Support Team (NST)
   - **Mission**: Provide **analytical, intelligence, and technical support** to NMTs.
   - **Function**: Enhance the ability of NMTs to develop operations through intelligence gathering, analysis, and target validation.
   - **Alignment**: Part of the CNMF, they are critical in shaping and guiding national-level cyber operations.
 - Cyber Protection Team (CPT)
   - **Mission**: Conduct **defensive cyberspace operations (DCO)** to secure, monitor, and defend DODIN and other friendly cyberspace terrain.
   - **Function**: Identify, counter, and mitigate active or potential threats through protective, investigative, and response activities.
   - **Alignment**: Part of the Cyber Protection Force (CPF).

### 1.3 Read and understand the following cyberspace operations doctrine:
 - JP 3-12 (Cyberspace Operations) - This publication outlines the organization, roles, missions, and operational principles of Joint cyberspace operations, detailing how forces conduct offensive, defensive, and DOD network operations to secure national interests across the cyberspace domain.
 - USCYBERCOM Operational Guidance 3-2 (DCO) - *unable to obtain document*
 - USCYBERCOM Cyber Warfare Publication (CWP 3-33.4) - *unable to obtain document*

### 1.4 Describe the mission and responsibilities of key organizations:
 - U.S. Cyber Command (USCC)
   - **Mission**: Directs, synchronizes, and coordinates cyberspace operations to defend and advance national interests.
   - **Responsibilities**:
     - Defend the DoD Information Network (DODIN).
     - Support Combatant Command (CCMD) global mission execution.
     - Strengthen the nation’s ability to withstand and respond to cyberattacks.
	 - Issues directives to all DoD components for global DODIN operations and certain Defensive Cyberspace Operations (DCO-IDM)
 - Director Operation Test and Evaluation (DOTE) - *Not specifically detailed in AFDP 3-12. Generally, DOT&E oversees testing and evaluation of new military systems, including cyber systems, to ensure effectiveness and survivability.*
 - Federally Funded Research and Development Centers (FFRDC) - *Not specifically mentioned in the document. Typically, FFRDCs provide objective research and analysis to the federal government, including cyber assessments and policy support.*
 - Central Intelligence Agency (CIA) - *While not detailed in AFDP 3-12, the CIA generally conducts foreign intelligence collection and operations, including cyber intelligence abroad in support of U.S. national security under Title 50 USC.*
 - Federal Bureau of Investigation (FBI)
   - **Mission**: Investigates and prosecutes federal cybercrimes.
   - **Responsibilities**: Leads cybercrime investigations in coordination with other federal and military partners
 - Department of Homeland Security (DHS)
   - **Mission**: Secures the U.S. government’s portion of cyberspace.
   - **Responsibilities**: Focuses on protecting critical infrastructure, federal networks, and public-private cyber partnerships
 - Defense Threat Reduction Agency (DTRA) - *Not explicitly covered in AFDP 3-12. DTRA typically supports DoD efforts to counter WMDs, including potential cyber aspects related to WMD systems.*
 - Defense Digital Service (DDS) - *Not listed in AFDP 3-12. DDS brings private-sector tech experts into DoD to solve critical problems, including improving cybersecurity.*
 - National Security Agency (NSA)
   - **Mission**: Provides signals intelligence and cybersecurity support to national defense.
   - **Responsibilities**:
	 - Supports offensive and defensive cyberspace operations.
	 - Plays a key role in cryptographic and cybersecurity protections for military and national systems
 - National Air and Space Intelligence Center (NASIC) - *Not detailed in AFDP 3-12, but NASIC generally provides intelligence on foreign air and space threats, which can include cyber-based threats to aerospace systems.*

### 1.5 Demonstrate knowledge of U.S. Code and its application to the Intelligence Community (IC) and Cyberspace Operations (Title 10, 18, and 50)

#### Title 10, U.S. Code – Armed Forces*

**Application to Cyberspace Operations**:
 - Governs the organization, training, and equipping of U.S. military forces, including cyberspace forces.
 - Most Defensive Cyberspace Operations (DCO) and DODIN operations are conducted under Title 10 authority.
 - Combatant commanders (CCDRs) and service component commanders (e.g., CDRAFCYBER) operate under this title for conducting operations within military scope.

**Key Points**:
 - Title 10 operations typically involve military capabilities in support of defense missions.
 - Operations may be conducted inside U.S. borders when authorized (e.g., in homeland defense scenarios).

#### Title 18, U.S. Code – Crimes and Criminal Procedure

**Application to Intelligence and Cyber**:
 - Governs federal criminal law enforcement, including computer crime statutes.
 - Primary authority for agencies like the FBI in investigating cybercrime and malicious activity within the U.S.

**Key Points**:
 - In cyberspace, Title 18 authorizes legal action against unauthorized access, fraud, and other cyber offenses.
 - Military personnel may support investigations under Title 18 in coordination with law enforcement (e.g., Air Force Office of Special Investigations).

#### Title 50, U.S. Code – War and National Defense

**Application to the Intelligence Community (IC) and Cyber**:
 - Covers national security, covert actions, and authorities of the Intelligence Community, including NSA, CIA, and DNI.
 - Most Offensive Cyberspace Operations (OCO) and Cyber ISR (Intelligence, Surveillance, and Reconnaissance) actions fall under Title 50.
 - Used when operations involve espionage, foreign surveillance, or covert cyber activities.

**Key Points**:
 - Title 50 missions require high-level approval—sometimes from the President or Secretary of Defense.
 - These actions are subject to oversight from congressional intelligence committees and typically involve coordinated interagency operations.

#### Summary

| U.S. Code Title | Domain | Primary Users | Scope | Example Activities |
| Title 10 | Armed Forces | DoD, Military | Military ops (defense) | Securing DODIN, DCO |
| Title 18 | Criminal Law | DOJ, FBI | Law enforcement | Cybercrime prosecution |
| Title 50 | Intelligence | NSA, CIA, DNI | Espionage, covert ops | Cyber ISR, OCO |

### 1.6 Describe the classification levels of the development networks and the associated handling requirements of source code and binaries for your organization.

*TBD*

### 1.7 Demonstrate knowledge of sources and locations (public and classified) of capability development TTPs and tradecraft information/intelligence used by the US Gov and others.

*TBD*

## 2.0 DCO Fundamentals

### 2.1 Describe the overall mission of a Cyber Protection Team (CPT).

To conduct Defensive Cyberspace Operations (DCO) to protect, detect, respond to, and recover from cyber threats targeting Department of Defense Information Networks (DODIN) or other designated friendly cyberspace terrain.

#### Core Responsibilities of a CPT:
 - **Identify and mitigate threats** that have bypassed existing security measures.
 - **Protect mission-critical systems, networks, and data** by conducting proactive and reactive defensive measures.
 - **Conduct threat hunting**, vulnerability assessments, and incident response.
 - **Support incident containment and recovery** in the event of a cyber breach.
 - Provide intelligence-informed defense through collaboration with other DCO, cyber ISR, and network operations teams.

#### Mission Scope:
 - **Protective DCO Activities**: Implement threat-informed security actions to minimize risk.
 - **Investigative DCO Activities**: Analyze and characterize active threats or intrusions.
 - **Response DCO Activities**: Take direct action to contain or mitigate ongoing attacks.

#### Deployment Flexibility:

 - **Internally (DCO-IDM)**: Within friendly networks (e.g., on-base or enterprise networks).
 - **Externally (DCO-RA)**: In foreign or non-DoD-controlled cyberspace, often without owner permission, to neutralize threats before they reach friendly systems.

### 2.2 Describe the CPT Support Element and Mission Element and their capabilities.

#### CPT Support Element

 - **Purpose**: Provides administrative, logistical, planning, and technical support to enable the CPT to operate effectively during missions.
 - **Key Capabilities**:
   - Mission Planning & Coordination: Develops and refines plans for mission execution, ensuring alignment with command guidance and operational objectives.
   - Cyber Threat Intelligence (CTI): Integrates intelligence to inform DCO tactics and identify adversary TTPs (Tactics, Techniques, and Procedures).
   - Logistics & Sustainment: Ensures the team has the tools, infrastructure access, and communications needed for both local and remote deployments.
   - Command & Control (C2) Liaison: Coordinates with higher headquarters (e.g., AFCYBER or USCYBERCOM), deconflicts operations, and reports mission status.
 - **Focus**: Mission enablement, readiness, and alignment with operational authorities.

#### CPT Mission Element

 - **Purpose**: Executes the hands-on-keyboard technical actions to defend and respond within cyberspace terrain.
 - **Key Capabilities**:
   - Threat Hunting: Actively searches for indicators of compromise (IOCs) and anomalous behavior within networks.
   - Network Traffic Analysis: Uses tools to monitor and inspect data flows, detect malicious activity, and identify unauthorized access.
   - Malware Analysis & Forensics: Investigates suspicious files or behaviors to determine threats and their impacts.
   - Incident Response: Responds to real-time events with mitigation actions (e.g., isolating infected systems, removing threats, restoring systems).
   - Vulnerability Assessments: Scans and evaluates network assets for known weaknesses or misconfigurations.
   - Sensor Deployment & Tuning: Installs, configures, and optimizes tools (like intrusion detection systems) to enhance network visibility.
 - **Focus**: Technical defense, analysis, and operational response.

### 2.3 Describe CPT mission types:

#### National CPT

 - **Mission**: Defend national-level cyberspace terrain not owned or operated by the Department of Defense but vital to national security (e.g., electoral infrastructure, critical infrastructure during crises).
 - **Key Characteristics**:
   - Operate under the Cyber National Mission Force (CNMF).
   - Support National Mission Teams (NMTs).
   - Engage in high-priority missions directed by USCYBERCOM, the Secretary of Defense, or even the President.
   - May defend non-DOD networks when ordered.

#### DoDIN CPT (Department of Defense Information Network CPT)

 - **Mission**: Defend the DoD’s global enterprise network infrastructure—the DoDIN.
 - **Key Characteristics**:
   - Protect internal, enterprise-wide DoD systems and services.
   - Focus on preventing, detecting, and responding to threats within the DoDIN.
   - Work closely with JFHQ-DODIN and DoD agencies responsible for network operations.

#### Combatant Command CPT

 - **Mission**: Defend cyberspace terrain directly supporting a Combatant Command’s (CCMD’s) missions and operations.
 - **Key Characteristics**:
   - Tasked to protect mission-relevant systems, such as regional command and control (C2), logistics, and intelligence nodes.
   - Aligned with a specific CCMD, e.g., EUCOM, CENTCOM, INDOPACOM.
   - Work with JFHQ-C (Joint Force Headquarters-Cyber) teams assigned to that region to coordinate defense efforts.
   - Enable theater-level operational continuity in contested cyber environments.

#### Service CPT

 - **Mission**: Defend service-specific networks and missions, such as those belonging to the Air Force, Army, Navy, or Marine Corps.
 - **Key Characteristics**:
   - Assigned by their parent service (e.g., Air Force CPTs under AFCYBER).
   - Provide organic cybersecurity for service-owned weapon systems, platforms, and infrastructure.
   - Often embedded in Mission Defense Teams (MDTs) that protect high-value service missions like air bases or ISR platforms.

### 2.4 Describe the following DCO work roles:

#### Cyber Operations Planner

 - **Mission**: Designs and coordinates the operational execution of DCO missions.
 - **Key Responsibilities**:
   - Develops defensive Courses of Action (COAs) aligned with command objectives.
   - Translates threat intelligence into actionable defense plans.
   - Works with CPTs, intelligence teams, and mission owners to align resources and priorities.
   - Integrates cyberspace operations with broader joint operations planning.

### Network Analyst

 - **Mission**: Monitors and assesses network activity to detect malicious behavior.
 - **Key Responsibilities**:
   - Analyzes packet capture (PCAP) data, flow logs, and intrusion detection system (IDS) alerts.
   - Identifies anomalous activity within network traffic.
   - Maps network topologies and tracks adversary movement across systems.
   - Works closely with host analysts to correlate events across endpoints and the network.

#### Host Analyst

 - **Mission**: Focuses on endpoint devices (e.g., servers, workstations) to identify compromises and ensure system integrity.
- **Key Responsibilities**:
   - Examines logs, memory, processes, and file systems to detect malicious activity.
   - Performs host-based forensics and malware triage.
   - Correlates events from multiple devices to identify coordinated attacks.
   - Responds to alerts triggered by host-based intrusion detection systems (HIDS).

#### Analytic Support Officer

 - **Mission**: Provides mission-critical intelligence and decision support for cyberspace operations.
 - **Key Responsibilities**:
   - Synthesizes inputs from threat intelligence, CTI reports, and operational assessments.
   - Helps commanders understand adversary tactics, techniques, and procedures (TTPs).
   - Supports planning and assessment cycles with tailored intelligence products.
   - Acts as a bridge between operational personnel and strategic-level analysts.

#### Data Engineer

 - **Mission**: Builds and maintains the data pipelines and infrastructure that enable large-scale cyber analytics and threat detection.
 - **Key Responsibilities**:
   - Develops and optimizes tools for parsing, storing, and visualizing cybersecurity data.
   - Supports automation of event correlation and threat hunting.
   - Works with analysts to ensure data availability and relevance.
   - May support machine learning/AI integration into cyber defense workflows.

#### Network Technician

 - **Mission**: Provides technical infrastructure support to ensure reliable operation of DCO tools and platforms.
 - **Key Responsibilities**:
   - Installs, configures, and maintains network and security appliances (e.g., firewalls, switches, sensors).
   - Supports implementation of defensive measures such as segmentation or access controls.
   - Troubleshoots connectivity and performance issues related to security tools.
   - Assists with deploying and maintaining monitoring infrastructure (e.g., sensors for CPT use).

#### All-Source Analyst

 - **Mission**: Integrates intelligence from multiple disciplines (e.g., SIGINT, HUMINT, OSINT, cyber) to create a comprehensive picture of the threat environment.
 - **Key Responsibilities**:
   - Fuses data from technical and non-technical sources to identify and assess threats.
   - Develops adversary profiles and forecasts potential cyber campaigns.
   - Informs DCO planning and prioritization with strategic and tactical insight.
   - Provides regular threat reporting to commanders and operators.

### 2.5 Read and understand the DNI threat assessments

 *Resources and task objectvies TBD*

 ## 3.0 OCO Fundamentals

 ### 3.1 Describe the difference between conducting Cyberspace Intelligence, Surveillance, and Reconnaissance (C-ISR) and Cyberspace Surveillance and Reconnaissance (C-SR).

The difference between Cyberspace Intelligence, Surveillance, and Reconnaissance (C-ISR) and Cyberspace Surveillance and Reconnaissance (C-SR) centers on **intent, authorities, and operational use** in the preparation and execution of offensive cyber missions.

#### Cyberspace Intelligence, Surveillance, and Reconnaissance (C-ISR)

 - **Purpose**: C-ISR is used to collect foreign intelligence to support target development, validate access, and understand adversary systems prior to executing an offensive cyberspace operation.
 - **Key Points**:
   - Governed by Title 50 U.S. Code (intelligence authorities).
   - Requires formal authorization (e.g., Execute Orders [EXORD], Presidential or SecDef-level approvals).
   - Supports detailed target characterization, including network topology, defensive measures, and access feasibility.
   - May involve clandestine access to foreign networks before an attack.
   - Conducted by intelligence units or national-level cyber teams (e.g., NSA, Cyber National Mission Force).
 - **Examples**:
   - Mapping out a foreign air defense network’s digital architecture to plan an exploit.
   - Gathering credentials or system version data to craft a tailored cyber payload.

#### Cyberspace Surveillance and Reconnaissance (C-SR)

 - **Purpose**: C-SR supports non-intelligence enabling activities that prepare or facilitate the OCO mission—but without collecting foreign intelligence.
 - **Key Points**:
   - Conducted under Title 10 U.S. Code (military operational authorities).
   - Used for mission rehearsal, verifying friendly cyber capability readiness, or establishing access to blue or gray terrain.
   - Helps ensure system access or payload delivery infrastructure is functioning properly.
   - Typically performed by the operational unit planning the OCO (e.g., Combat Mission Teams).
 - **Examples**:
   - Testing a malware deployment method within a controlled, non-adversary environment.
   - Scanning an allied-hosted server for potential access paths (with permission) before initiating the strike phase.

**Summary**:

| Feature | C-ISR | C-SR |
| Legal Authority | Title 50 (Intelligence) | Title 10 (Operational / Military) |
| Primary Use | Target development and adversary intelligence | Mission setup, access prep, capability rehearsal |
| Collects Foreign Intel? | Yes | No |
| Requires Special Approval? | Yes (e.g., EXORD, Intel Oversight) | No (standard military authority) |
| Example Activity | Identifying vulnerabilities in enemy SCADA | Verifying delivery infrastructure on blue/gray net |
| Typical Actors | NSA, CNMF, CMTs with intel tasking | Combat Mission Teams (CMTs), Service units |

### 3.2 Describe the following OCO work roles:

#### Remote Operator (ION/RO)

 - **Mission**: Executes hands-on-keyboard (HOK) operations to deliver cyber effects through access and exploitation in red or gray cyberspace.
 - **Key Responsibilities**:
   - Deploys payloads, establishes and maintains access.
   - Navigates foreign networks to position effects.
   - Executes mission scripts/tools and maintains stealth and persistence.
   - Responds dynamically to changes in network behavior during operations.

#### Mission Commander (MC)

- **Mission**: Leads the end-to-end planning and execution of an OCO mission.
 - **Key Responsibilities**:
  -	Owns mission risk and makes real-time decisions during execution.
  -	Coordinates between planners, intelligence analysts, and ROs.
  -	Ensures compliance with Rules of Engagement (ROE) and legal authorities.
  -	Approves final strike actions (digital effects) within authorized parameters.

#### Exploitation Analyst (EA)

- **Mission**: Analyzes adversary systems and networks to identify vulnerabilities and potential effects pathways.
- **Key Responsibilities**:
  -	Maps target network architecture and software ecosystems.
  -	Conducts vulnerability research and development support.
  -	Supports payload development and access strategies.
  -	Works with tool developers and ROs to exploit target systems.

#### Digital Network Exploitation Analyst (DNEA) & Target Digital Network Analyst (TDNA)

- **Mission**: Discover, track, and develop digital targets using SIGINT and cyber tools.
- **Key Responsibilities**:
  -	DNEA: Focuses on access and exploitation of digital networks (e.g., infrastructure, routing, services).
  -	TDNA: Tracks and characterizes specific digital personas or entities across the cyber terrain.
  -	Conduct link analysis and identity resolution.
  -	Feed intelligence to planners and tool developers.

#### Operational Target Development Analyst (OTDA), Targeteer, and Fire Support Planner

- **Mission**: Turn raw intelligence and access into targetable entities and match cyber effects with desired operational outcomes.
- **Key Responsibilities**:
  -	OTDA: Builds target profiles and vetting packages from cyber intel.
  -	Targeteer: Matches target vulnerabilities with appropriate cyber capabilities.
  -	Fire Support Planner: Integrates cyber operations into joint targeting and kinetic/non-kinetic strike planning.

#### Cyber Operations Planner

- **Mission**: Designs OCO missions in alignment with joint force objectives and operational authorities.
- **Key Responsibilities**:
  -	Develops Course of Action (COA) options.
  -	Coordinates access, payload, intelligence, and legal approval timelines.
  -	Integrates cyber effects into broader campaign plans.
  -	Ensures effects are synchronized with air, land, sea, space, and information ops.

#### Team Lead & Deputy Team Lead (TL / DTL)

- **Mission**: Manages daily team operations, resource allocation, and mission execution across CMTs or NMTs.
- **Key Responsibilities**:
  -	TL: Operational authority over mission and personnel; ensures readiness and execution of cyber effects.
  -	DTL: Assists in mission oversight, administrative responsibilities, and task delegation.
  -	Represent team in operational briefs and mission planning forums.

#### Language Analyst (LA)

- **Mission**: Provides foreign language translation and cultural context to enable deeper understanding of cyber targets.
- **Key Responsibilities**:
  -	Translates foreign language communications and artifacts (e.g., malware code comments, emails).
  -	Identifies linguistic indicators in command and control channels.
  -	Supports attribution, intent analysis, and tool behavior interpretation.

#### Target Analyst Reporter (TAR)

- **Mission**: Authors formal intelligence reports based on target behavior, capability, and intent observed during OCO.
- **Key Responsibilities**:
  -	Converts analyst and operator findings into serialized intelligence products (e.g., SIGINT reports).
  -	Ensures reporting adheres to classification, dissemination, and oversight standards.
  -	Collaborates with other IC elements to support strategic objectives and warn stakeholders.

## 4.0 Mission Process

### 4.1 Describe the CCDO standard of interaction between a capability development organization and its higher requirements-generating headquarters, including pre-requirement planning, drafting requirements, and interacting with tool champions, product owners, or requirement-owning stakeholders.

The standard lays out structured, repeatable phases that promote collaboration, alignment, and accountability between CDOs (e.g., tool developers, software engineers, cyber R&D labs) and stakeholders (e.g., USCYBERCOM, AFCYBER, NSA) who own or generate mission requirements.

#### 1. Pre-Requirement Planning Phase

 - **Purpose**: To enable early coordination and mutual understanding before a formal requirement is written.
 - **Activities Include**:
   - Engagement workshops or tech exchanges between the CDO and the requirement-generating HQ.
   - Identification of gaps, opportunities, and emerging threats.
   - Sharing tech roadmaps and aligning R&D direction with anticipated mission needs.
   - Determining potential tool champions or product owners within operational units who can validate utility.
 - **Goal**: Shape feasible, mission-aligned requirements based on CDO capabilities and stakeholder priorities.

#### 2. Drafting Requirements Phase

 - **Purpose**: To collaboratively develop actionable and technically-informed cyber requirements.
 - **Activities Include**:
   - Stakeholders draft requirement documents (e.g., Capability Development Packages or JCTDs).
   - CDO provides technical feedback on feasibility, estimated timelines, and integration needs.
   - Early validation occurs with tool champions, planners, and mission elements to ensure operational relevance.
   - Security, legal, and policy constraints are reviewed early.
 - **Goal**: Ensure the requirement is technically sound, well-scoped, and implementable within the existing capability ecosystem.

#### 3. Ongoing Interaction with Tool Champions, Product Owners, and Stakeholders

 - **Purpose**: To refine, test, and transition the capability into operational use.
 - **Key Interactions**:
   - Tool champions (often operators or subject matter experts) help evaluate prototypes, test features, and validate usability.
   - Product owners within the development team prioritize feature sets based on mission impact and operator feedback.
   - Requirement-owning stakeholders (e.g., USCYBERCOM mission elements) track progress, adjust priorities, and assess capability effectiveness.
 - **Common Practices**:
   - Agile-style development sprints and regular reviews (e.g., demos, retrospectives).
   - Rapid prototyping and fielding to support Combat Mission Teams (CMTs) or Cyber Protection Teams (CPTs).
   - Use of tech insertion paths, such as the Cyber Operations Mission Force (CMF) DevSecOps pipeline or Mission Platform integrations.

#### Key Outcomes of Effective CCDO Interaction
 - Accelerated fielding of cyber capabilities with high operational utility.
 - Clear traceability from strategic objectives to technical features.
 - Increased collaboration across development, operations, and intelligence communities.
 - Reduced risk of capability mismatch, delays, or shelfware tools.

### 4.2 Describe the U.S. Cyber Command testing and evaluation process, including Developmental Test and Evaluation, Developmental Acceptance, Evaluated Level of Assurance, and Operational Test and Evaluation.

#### 1. Developmental Test and Evaluation (DT&E)

 - **Purpose**: To validate that the tool or capability functions correctly and reliably in a controlled test environment.
 - **Activities**:
   - Conducted early and throughout the development cycle.
   - Includes functionality testing, performance evaluation, and interoperability verification.
   - Focuses on identifying defects, verifying design, and ensuring that developmental progress aligns with requirements.
 - **Outcome**: A baseline understanding of system maturity and readiness for integration.

#### 2. Developmental Acceptance

 - **Purpose**: To confirm the capability is safe, secure, and functional enough for limited operational use.
 - **Activities**:
   - A formal review is conducted to determine whether a tool can be transitioned from the development environment to a mission-accessible enclave.
   - Evaluates whether the capability meets minimum security and performance thresholds.
   - May include vulnerability assessments, code reviews, and static/dynamic analysis.
 - **Outcome**: The tool is accepted for limited deployment and is made available for operator use under controlled conditions.

#### 3. Evaluated Level of Assurance (ELA)

 - **Purpose**: To provide a cybersecurity confidence rating that reflects the tool’s resilience against compromise and unauthorized use.
 - **Activities**:
   - Scoring and categorization based on depth of security testing and mitigations in place.
   - ELA is assigned by a cybersecurity authority after rigorous assurance testing.
   - Higher levels of ELA are required for tools with significant operational impact or risk.
 - **Outcome**: An official determination that the tool meets an acceptable level of cybersecurity assurance for its intended mission use.

#### 4. Operational Test and Evaluation (OT&E)

 - **Purpose**: To validate that the capability is effective, suitable, and survivable in a real-world operational environment.
 - **Activities**:
   - Conducted by operational forces (e.g., Combat Mission Teams, Cyber Protection Teams).
   - Focuses on mission utility, user experience, and how the tool performs under real or simulated threat conditions.
   - Includes end-user feedback and assessments of mission impact.
 - **Outcome**: Decision-makers determine whether to fully deploy the capability across the force, refine it further, or terminate its development.

 #### Summary

 ```
 [ DT&E ] → [ Developmental Acceptance ] → [ ELA Rating ] → [ OT&E ] → [ Full Fielding or Rework ]
 ```

This process ensures that cyber capabilities are not only **operationally relevant**, but also **technically safe and secure** before use in sensitive or mission-critical environments.

### 4.3 Describe an example of software development/documentation best practices.

#### Software Development Best Practices

 - Version Control
   - Use Git or another VCS for all codebases.
   - Commit early, commit often, and write meaningful commit messages.
   - Maintain a main (or master) branch for production-ready code and use feature branches for development.
 - Code Reviews
   - Conduct peer reviews before merging code.
   - Focus on readability, security, performance, and maintainability.
   - Use tools like GitHub/GitLab Pull Requests or Gerrit.
 - Modular and Reusable Code
   - Design components to be loosely coupled and highly cohesive.
   - Follow the DRY principle (Don’t Repeat Yourself).
   - Break up logic into functions, classes, or services with single responsibility.
 - Coding Standards and Style Guides
   - Use linters and formatters (e.g., black, pylint, eslint).
   - Adopt language-specific style guides (e.g., PEP8 for Python, Google Style for C++).
   - Maintain naming conventions and consistent code structure.
 - Automated Testing
   - Implement unit, integration, and end-to-end tests.
   - Use frameworks like pytest, JUnit, Mocha, or Selenium.
   - Set up Continuous Integration (CI) to run tests on every commit.
 - Secure Coding Practices
   - Validate and sanitize inputs to prevent injection attacks.
   - Handle authentication, authorization, and cryptography carefully.
   - Use static and dynamic analysis tools for vulnerability detection.

#### Documentation Best Practices

 - README Files
   - Include project purpose, how to install, usage examples, and contributor guidelines.
   - Make sure it’s updated regularly as the codebase evolves.
 - Code Comments
   - Use comments to explain why, not just what.
   - Avoid redundant or obvious comments; aim for clarity and relevance.
 - API Documentation
   - Use tools like Swagger/OpenAPI, Sphinx, or JSDoc to auto-generate API docs.
   - Include endpoint descriptions, parameters, response formats, and error codes.
 - Changelogs
   - Maintain a CHANGELOG.md to track feature updates, bug fixes, and breaking changes.
   - Follow Keep a Changelog guidelines for consistency.
 - Architecture & Design Docs
   - Provide high-level overviews: system architecture, major components, data flows.
   - Include diagrams (UML, sequence charts) where useful.
   - Store documents in a versioned and accessible location (e.g., repo /docs folder or Confluence).

####  DevOps Integration Practices
   - Use CI/CD pipelines (e.g., GitHub Actions, GitLab CI, Jenkins).
   - Automate deployments and integrate infrastructure-as-code (IaC).
   - Monitor performance and log key metrics using tools like Grafana, Prometheus, or ELK stack.

## 5.0 Style Fundamentals

### 5.1 With references, resources, and a provided unit-level coding standard or style guide, identify coding standard violations in Python source code.

Common PEP8 violations:

#### Indentation Errors

**Violation**: Incorrect number of spaces or mixing tabs and spaces.

❌ Bad:
```
def say_hello():
print("Hello")  # Missing indentation
```

✅ Good:
```
def say_hello():
    print("Hello")  # 4 spaces per PEP 8
```

#### Inconsistent or Non-descriptive Variable Naming

**Violation**: Using unclear or non-PEP 8 compliant variable names.

❌ Bad:
```
A = 5
b2 = "name"
```

✅ Good:
```
age = 5
user_name = "name"
```

#### Trailing Whitespace

**Violation**: Extra spaces at the end of a line.

❌ Bad:
```
print("Hello")
```

✅ Good:
```
print("Hello")
```

#### Lines Too Long (> 79 characters)

**Violation**: Writing long, unreadable lines.

❌ Bad:
```
print("This is a very long string that definitely goes beyond seventy-nine characters in total which is not okay according to PEP 8.")
```

✅ Good:
```
print(
    "This is a very long string that definitely goes beyond seventy-nine "
    "characters in total which is not okay according to PEP 8."
)
```

#### Unused Imports

**Violation**: Importing modules you never use.

❌ Bad:
```
import os
import sys

print("Hello")
```

✅ Good:
```
print("Hello")
```

#### Mutable Default Arguments

**Violation**: Using mutable types as function defaults.

*In Python, default arguments are evaluated only once—when the function is defined, not each time it is called. So if the default is a mutable object (like a list or dictionary), and you modify it, that modified version persists across future function calls.*

❌ Bad:
```
def append_item(item, items=[]):
    items.append(item)
    return items
```

✅ Good:
```
def append_item(item, items=None):
    if items is None:
        items = []
    return items

```

#### Missing or Incorrect Docstrings

**Violation**: No docstring for public modules, classes, or functions.

❌ Bad:
```
def add(a, b):
    return a + b
```

✅ Good:
```
def add(a, b):
    """Return the sum of a and b."""
    return a + b
```

#### Using Bare except:

**Violation**: Catching all exceptions without specifying the type.

*Using a bare except: in Python is considered bad practice because it catches all exceptions indiscriminately, including system-exiting exceptions like KeyboardInterrupt, SystemExit, and even serious internal errors like MemoryError or GeneratorExit.*

❌ Bad:
```
try:
    risky_action()
except:
    print("Something went wrong")
```

✅ Good:
```
try:
    risky_action()
except Exception as e:
    print(f"Error: {e}")
```

#### Import Ordering

**Violation**: Imports are not grouped logically (standard, third-party, local).

❌ Bad:
```
import requests
import os
import mymodule
```

✅ Good:
```
import os

import requests

import mymodule
```

#### Comparison to None using == or !=

**Violation**: Not using is / is not for None.

*"is None" is faster (no method calls) and safer (cant be overrided)*

❌ Bad:
```
if val == None:
    pass
```

✅ Good:
```
if val is None:
    pass
```

You can run a linter like `flake8` or `pylint` on your code and help clean up violations automatically.

### 5.2 With references, resources, and a provided unit-level coding standard or style guide, identify coding standard violations in C source code.

#### Missing Braces in Control Structures

**Violation**: Omitting braces can lead to logic errors if the code is modified later.

❌ Bad:
```
if (x > 0)
    printf("Positive number\n");
```

✅ Good:
```
if (x > 0) {
    printf("Positive number\n");
}
```

####  Improper Use of == Instead of = or Vice Versa

**Violation**: Confusing assignment (=) with comparison (==), often in conditionals.

❌ Bad:
```
if (x = 5) {  // Assignment, not comparison!
    // Always true if x is non-zero
}
```

✅ Good:
```
if (x == 5) {
    // Correct comparison
}
```

#### Magic Numbers

**Violation**: Using literal numbers instead of named constants.

❌ Bad:
```
if (speed > 88) {
    printf("Time travel engaged!\n");
}
```

✅ Good:
```
#define TIME_TRAVEL_SPEED 88

if (speed > TIME_TRAVEL_SPEED) {
    printf("Time travel engaged!\n");
}
```

#### Unsafe Functions (e.g., gets(), strcpy())

**Violation**: Using functions that are vulnerable to buffer overflows.

❌ Bad:
```
char name[10];
gets(name);  // 🚨 Dangerous
```

✅ Good:
```
char name[10];
fgets(name, sizeof(name), stdin);
```

#### Unused Variables

**Violation**: Declaring variables that are never used, leading to clutter and confusion.

❌ Bad:
```
int unused_var;
int used_var = 5;
printf("%d\n", used_var);
```

✅ Good:
```
int used_var = 5;
printf("%d\n", used_var);
```

#### Missing return in Non-void Functions

**Violation**: Not returning a value from a function that expects one.

❌ Bad:
```
int compute_sum(int a, int b) {
    int sum = a + b;
    // missing return
}
```

✅ Good:
```
int compute_sum(int a, int b) {
    return a + b;
}
```

#### Failing to Check Return Values

**Violation**: Ignoring return values from critical functions like `malloc`, `fopen`, etc.

❌ Bad:
```
FILE *fp = fopen("data.txt", "r");
// use fp without checking
```

✅ Good:
```
FILE *fp = fopen("data.txt", "r");
if (fp == NULL) {
    perror("File open failed");
    return 1;
}
```

#### Improper Loop Conditions (Off-by-One Errors)

**Violation**: Incorrect indexing or loop bounds.

❌ Bad:
```
for (int i = 0; i <= 10; i++) {
    array[i] = i;  // If array[10] doesn't exist → overflow
}
```

✅ Good:
```
for (int i = 0; i < 10; i++) {
    array[i] = i;
}
```

#### Integer Division Mistakes

**Violation**: Expecting floating-point results from integer division.

❌ Bad:
```
int a = 5, b = 2;
float result = a / b;  // result = 2.0, not 2.5
```

✅ Good:
```
float result = (float)a / b;  // result = 2.5
```

#### Improper const Usage

**Violation**: Modifying data that should be read-only or not protecting inputs.

❌ Bad:
```
void print_name(char *name) {
    printf("%s\n", name);
    name[0] = 'X';  // Can be modified!
}
```

✅ Good:
```
void print_name(const char *name) {
    printf("%s\n", name);
}
```

## 6.0 C Programming

### 6.1 Describe the purpose and use of C programming fundamentals:

- The main() Function
   - **Purpose**: It’s the entry point of any C program.
   - **Use**: Execution starts from main(). It can return an integer to indicate success (0) or failure (non-zero) to the operating system.
 - The return Statement
   - **Purpose**: Ends a function and optionally returns a value to the caller.
   - **Use**: In main(), return 0; signals successful completion. In other functions, it sends data back to where the function was called.
 - Macro Guards
   - **Purpose**: Prevent multiple inclusion of the same header file.
   - **Use**: Implemented using #ifndef, #define, and #endif.
 - Data Types
   - **Purpose**: Define the type and size of data.
   - **Use**: Examples: int, char, float, double, struct, union.
 - Functions and Procedures
   - **Purpose**: Organize code into reusable blocks.
   - **Use**: Functions return values, procedures (void functions) do not.
 - Parameters
   - **Purpose**: Allow data to be passed into functions.
   - **Use**: Used in function definitions and calls to supply values or references.
 - Scope
   - **Purpose**: Determines visibility/lifetime of variables.
   - **Use**: Local (inside functions/blocks), Global (outside functions), or Static (preserves value between calls).
 - Return Values (Return Type and Reference)
   - **Purpose**: Functions return data using a defined type.
   - **Use**: Can return a direct value or a pointer/reference.
 - Header Files
   - **Purpose**: Declare functions, macros, and data types to be shared.
   - **Use**: Use #include to import. Often used for interface definitions.
 - Keywords (static and extern)
   - `static`:
      - Limits variable/function scope to the file.
      - Keeps local variables persistent between function calls.
   - `extern`:
      - Declares a variable/function defined in another file.
 - Pointers
   - **Purpose**: Store memory addresses, enable dynamic memory, and function references.
   - **Use**: Vital for arrays, strings, and efficient function calls.
 - An Array
   - **Purpose**: Stores multiple items of the same type.
   - **Use**: Fixed-size, contiguous memory storage.
 - C Preprocessor
   - **Purpose**: Handles directives before actual compilation.
   - **Use**: Macros (#define), file inclusion (#include), conditional compilation (#ifdef).
 - Casting
   - **Purpose**: Converts a variable from one type to another.
   - **Use**: `float f = (float)5 / 2; // 2.5`
 - Control Flow
   - **Purpose**: Direct program execution paths.
   - **Use**: if, else, switch, while, for, break, continue, goto.
 - Endianness
   - **Purpose**: Describes byte order in memory (big-endian vs little-endian).
   - **Use**: Important in low-level programming, network protocols, and binary file parsing.
 - Multi-byte vs. Unicode Character Sets
   - **Purpose**: Deal with international text and encoding formats.
   - **Use**:
   - Multi-byte: Legacy systems (e.g., Shift-JIS).
   - Unicode: Wide character support (UTF-8, UTF-16), wchar_t in C.
 - Multi-threading
   - **Purpose**: Execute multiple threads for parallelism and concurrency.
   - **Use**: Achieved using libraries like POSIX Threads (pthreads).
 - Hashing
   - **Purpose**: Map data to a fixed-size value, often for fast lookup.
   - **Use**: Implementing hash tables, checksums, and cryptography.

### 6.2 Describe C programming concepts in regards to memory:

#### Memory Map of a Linux Process

A typical memory layout of a Linux process looks like this:
```
+---------------------+
|     Stack           | ← Grows downward
+---------------------+
|     Heap            | ← Grows upward
+---------------------+
| Uninitialized Data  | (.bss)
+---------------------+
| Initialized Data    | (.data)
+---------------------+
|     Text (code)     |
+---------------------+
```

 - **Text Segment**: Stores the compiled machine code (read-only).
 - **.data Segment**: Stores global/static variables with initial values.
 - **.bss Segment**: Stores global/static variables with no initial value.
 - **Heap**: Memory for dynamically allocated variables (malloc, calloc, etc.).
 - **Stack**: Memory for local (automatic) variables and function call frames.

 #### Automatically Allocated Memory

 - **What it is**: Memory automatically managed by the compiler.
 - **Where**: Located in the stack.
 - **Lifetime**: Exists only during the function’s execution.

 #### Dynamically Allocated Memory

 - **What it is**: Memory explicitly allocated by the programmer at runtime.
 - **Where**: Located in the heap.
 - **Lifetime**: Persists until explicitly freed using free().

#### Statically Allocated Memory

 - **What it is**: Memory for variables whose size and lifetime are fixed at compile-time.
 - **Where**: In the .data (if initialized) or .bss (if uninitialized) segment.
 - **Lifetime**: From program start to program termination.

#### Automatic vs Dynamic allocation in terms of stack and heap

 - **Stack**
   - Used for automatic/local variabled and function call information
   - Managed automatically by the compiler and runtime
   - Grows/shrinks as functions are called/return
 - **Heap**
   - Used for dynamic allocations
   - Managed manually by the programmer
   - Grows/shrinks based on explicit `malloc`/`free` calls

### 6.3 Demonstrate the proper declaration, understanding, and use of C data types and underlying structures:

`char`
 - **Purpose**: Represents a single character or small integer
 - **Typical size**: 1 byte (8 bits)
 - **Range**: -128 to 127 (signed) or 0 to 255 (unsigned)
 - **Underlying structure**: Stored as an integer (ASCII/Unicode code point).
```
char letter = 'A';      // character literal
char newline = '\n';    // escape sequence
unsigned char u = 200;  // avoid negative values
printf("char: %c (%d)\n", letter, letter);
```

`short`
 - **Purpose**: Small integer, typically used to save memory
 - **Typical size**: 2 bytes (16 bits)
 - **Range**: -32,768 to 32,767 (signed), 0 to 65,535 (unsigned)
```
short s = 32000;
unsigned short us = 65000;
printf("short: %d, unsigned short: %u\n", s, us);
```

`int`
 - **Purpose**: The *default* integer type
 - **Typical size**: 4 bytes (32 bits)
 - **Range**: -2,147,483,648 to 2,147,483,647
```
int x = 1000;
unsigned int ux = 4000000000U;  // requires unsigned
printf("int: %d, unsigned int: %u\n", x, ux);
```

`long`
 - **Purpose**: Larger integer for extended range
 - **Typical size**: 8 bytes (64 bits)
 - **Range**:  -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807 (signed), 0 to 18,446,744,073,709,551,615 (unsigned)
```
long l = 1000000000L;       // suffix L
unsigned long ul = 3000000000UL;
printf("long: %ld, unsigned long: %lu\n", l, ul);
```

`long long`
 - **Purpose**: Guaranteed 64-bit integer
 - **Typical size**: 8 bytes (64 bits)
 - **Range**:-9,223,372,036,854,775,808 to 9,223,372,036,854,775,807
```
long long big = 9000000000000000000LL;
unsigned long long ubig = 18000000000000000000ULL;
printf("long long: %lld, unsigned long long: %llu\n", big, ubig);
```

`float`
 - **Purpose**: Single-precision floating point
 - **Typical size**: 4 byts (32 bits)
 - **Precision**: ~7 decimal digits
```
float f = 3.14159f;   // suffix f
printf("float: %.7f\n", f);
```

`double`
 - **Purpose**: Double-precision floating point
 - **Typical size**: 8 bytes (64 bits)
 - **Precision**: ~15 decimal digits
```
double d = 3.141592653589793;
printf("double: %.15f\n", d);
```

`long double`
 - **Purpose**: Extended-precision floating point
 - **Typical size**: 16 bytes (80-bit or 128-bit precision)
 - **Precision**: ~20 decimal digits
```
long double ld = 3.141592653589793238462643383279L;
printf("long double: %.21Lf\n", ld);
```

###6.3 Demonstrate proper declaration, understanding, and use of fixed-width C data types defined in `stdint.h`:

`int8_t` & `uint8_t`
 - **Width**: 8 bits (1 byte)
 - **Range**: -128 to 127 (signed), 0 to 255 (unsigned)
```
#include <stdio.h>
#include <stdint.h>

int8_t a = -100;
uint8_t b = 200;
printf("int8_t a = %d\n", a);
printf("uint8_t b = %u\n", b);
```

`int16_t` & `uint16_t`
 - **Width**: 16 bits (2 bytes)
 - **Range**: -32,768 to 32,767 (signed), 0 to 65,535 (unsigned)
```
#include <stdio.h>
#include <stdint.h>

int16_t s = -30000;
uint16_t us = 60000;
printf("int16_t: %d, uint16_t: %u\n", s, us);
```

`int32_t` & `uint32_t`
 - **Width**: 32 bits (4 bytes)
 - **Range**: -2,147,483,648 to 2,147,483,647 (signed), 0 to 4,294,967,295 (unsigned)
```
#include <stdio.h>
#include <stdint.h>

int32_t i = -2000000000;
uint32_t ui = 4000000000U;
printf("int32_t: %d, uint32_t: %u\n", i, ui);
```

`int64_t` & `uint64_t`
 - **Width**: 64 bits (8 bytes)
 - **Range**: −9,223,372,036,854,775,808 to +9,223,372,036,854,775,807 (signed), 0 to 18,446,744,073,709,551,615 (unsigned)
```
#include <stdio.h>
#include <stdint.h>

int64_t big = -9000000000000000000LL;
uint64_t ubig = 18000000000000000000ULL;
printf("int64_t: %lld, uint64_t: %llu\n", big, ubig);
```

###6.5 Demonstrate the ability to creat eand implement a function that uses different arrays:

**array**
```
#include <stdio.h>

// Function that takes an array and its size, returns sum of elements
int sumArray(int arr[], int size) {
    int sum = 0;
    for (int i = 0; i < size; i++) {
        sum += arr[i];   // access each element by index
    }
    return sum;
}

int main(void) {
    int numbers[5] = {10, 20, 30, 40, 50};  // declare and initialize array
    int total = sumArray(numbers, 5);       // pass array to function

    printf("The sum of the array is: %d\n", total);
    return 0;
}
```

**multi-dimensional array**
```
#include <stdio.h>

// Function to add two 2D arrays (matrices) of size rows x cols
void addMatrices(int rows, int cols,
                 int A[rows][cols],
                 int B[rows][cols],
                 int Result[rows][cols])
{
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            Result[i][j] = A[i][j] + B[i][j];
        }
    }
}

// Function to print a 2D array
void printMatrix(int rows, int cols, int M[rows][cols]) {
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            printf("%4d ", M[i][j]);
        }
        printf("\n");
    }
}

int main(void) {
    int A[2][3] = {
        {1, 2, 3},
        {4, 5, 6}
    };

    int B[2][3] = {
        {6, 5, 4},
        {3, 2, 1}
    };

    int Result[2][3];  // to store the sum

    addMatrices(2, 3, A, B, Result);

    printf("Matrix A:\n");
    printMatrix(2, 3, A);

    printf("\nMatrix B:\n");
    printMatrix(2, 3, B);

    printf("\nResult (A + B):\n");
    printMatrix(2, 3, Result);

    return 0;
}
```

###6.6 Demonstrate the avility to perfrom basic arithmetic operations using C operators while ensuring PEMDAS

```
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>
#include <math.h>

#define MAX 100

// Stack for integers
typedef struct {
    int data[MAX];
    int top;
} IntStack;

// Stack for operators
typedef struct {
    char data[MAX];
    int top;
} CharStack;

void pushInt(IntStack *s, int val) {
    s->data[++s->top] = val;
}
int popInt(IntStack *s) {
    return s->data[s->top--];
}
int peekInt(IntStack *s) {
    return s->data[s->top];
}

void pushChar(CharStack *s, char val) {
    s->data[++s->top] = val;
}
char popChar(CharStack *s) {
    return s->data[s->top--];
}
char peekChar(CharStack *s) {
    return s->data[s->top];
}
int isEmptyChar(CharStack *s) {
    return s->top == -1;
}

// Precedence of operators
int precedence(char op) {
    switch (op) {
        case '^': return 3;
        case '*': case '/': return 2;
        case '+': case '-': return 1;
        default: return 0;
    }
}

// Check if operator is right-associative
int isRightAssociative(char op) {
    return op == '^';
}

// Convert infix expression to postfix using Shunting Yard
void infixToPostfix(const char *expr, char output[][MAX], int *outSize) {
    CharStack ops = {.top = -1};
    *outSize = 0;

    for (int i = 0; expr[i]; i++) {
        if (isspace(expr[i])) continue;

        if (isdigit(expr[i])) {
            char number[MAX];
            int j = 0;
            while (isdigit(expr[i])) {
                number[j++] = expr[i++];
            }
            number[j] = '\0';
            strcpy(output[(*outSize)++], number);
            i--; // step back
        } else if (expr[i] == '(') {
            pushChar(&ops, expr[i]);
        } else if (expr[i] == ')') {
            while (!isEmptyChar(&ops) && peekChar(&ops) != '(') {
                char op[2] = {popChar(&ops), '\0'};
                strcpy(output[(*outSize)++], op);
            }
            popChar(&ops); // remove '('
        } else { // operator
            while (!isEmptyChar(&ops) &&
                   precedence(peekChar(&ops)) > 0 &&
                   (precedence(peekChar(&ops)) > precedence(expr[i]) ||
                    (precedence(peekChar(&ops)) == precedence(expr[i]) &&
                     !isRightAssociative(expr[i])))) {
                char op[2] = {popChar(&ops), '\0'};
                strcpy(output[(*outSize)++], op);
            }
            pushChar(&ops, expr[i]);
        }
    }
    while (!isEmptyChar(&ops)) {
        char op[2] = {popChar(&ops), '\0'};
        strcpy(output[(*outSize)++], op);
    }
}

// Evaluate postfix expression
int evalPostfix(char tokens[][MAX], int size) {
    IntStack values = {.top = -1};

    for (int i = 0; i < size; i++) {
        if (isdigit(tokens[i][0]) || (tokens[i][0] == '-' && isdigit(tokens[i][1]))) {
            pushInt(&values, atoi(tokens[i]));
        } else {
            int b = popInt(&values);
            int a = popInt(&values);
            switch (tokens[i][0]) {
                case '+': pushInt(&values, a + b); break;
                case '-': pushInt(&values, a - b); break;
                case '*': pushInt(&values, a * b); break;
                case '/': pushInt(&values, a / b); break;
                case '^': pushInt(&values, (int)pow(a, b)); break;
            }
        }
    }
    return popInt(&values);
}

int main(void) {
    char expr[MAX];
    printf("Enter an expression: ");
    fgets(expr, MAX, stdin);

    char postfix[MAX][MAX];
    int size = 0;

    infixToPostfix(expr, postfix, &size);
    int result = evalPostfix(postfix, size);

    printf("Result = %d\n", result);
    return 0;
}
```

###6.7 Demonstrate the ability to properly use the standard main() entry arguments:

```
#include <stdio.h>

int main(int argc, char *argv[]) {
    // Print hello world by default
    if (argc == 1) {
        printf("Hello, World!\n");
    } else {
        // If arguments are provided, print them
        printf("Hello, ");
        for (int i = 1; i < argc; i++) {
            printf("%s", argv[i]);
            if (i < argc - 1) {
                printf(" ");  // space between arguments
            }
        }
        printf("!\n");
    }

    return 0;
}
```

###6.8 Demonstrate the ability to perform file management operations in C:

**Open an existing file**
```

```

**Read data from a file**
```

```

**Write data to a file**
```

```

**Modify data in a file**
```

```

**Close an open file**
```

```

**Print file information to the console**
```

```

**Create a new file**
```

```

**Append data to an existing file**
```

```

**Delete a file**
```

```

**Determine the size of a file**
```

```

**Determine the location within a file**
```

```

**Insert data into an existing file**
```

```

###6.9 Demonstrate the ability to create and implement functions that meet a requirement:
**Proper declaration for created functions**
```

```

**A function that doesnt return a value**
```

```

**A function that passes an argument by value**
```

```

**A function that takes a pointer argument**
```

```

**A function that returns a value using a return statement**
```

```

**A function that modifies an output paramater through a pointer**
```

```

**A function that receives input from a user**
```

```

**A function pointer**
```

```

**A recursive function**
```

```

###6.10 Demonstrate the ability to perform data validation
**Validate input received matches input expected**
```

```

##6.11 Demonstra skill in using pointers
**Declare an integer pointer**
```

```

**Dereference a variable to get its value**
```

```

**Printing the address of the variable**
```

```

**Assigning a value to a pointer**
```

```

**Make use of a function pointer to call another function**
```

```

**Make effective use of pointer arithmetic to traerse an array**
```

```

###6.12 Demonstrate skill in creating and implementing condition statements, expressions, and constructs:
**for loop**
```

```

**while loop**
```

```

**do while loop**
```

```

**if statement**
```

```

**if/else statement**
```

```

**if/else if/else statement**
```

```

**switch statement**
```

```

**effectige use of goto labels to construct a single exit point within a function**
```

```

###6.13 Demonstrate skill in creating and implementing a sort routine:
```

```

###6.14 Given a specification for a stateful application or protocol, describe a diagrame of the possible states it can have

###6.15 Describe terms associated with compiling, linking, debugging, and executables:
 - **Portable Executable (PE)**:
 - **Executable and Linkable Format**:
 - **Difference between PE and ELF**:
 - **Difference between a library and regualr executable program**:
 - **Calling convention/Application Binary Interface (ABI)**:

 ###6.16 Demonstrate skill in compiling, linking, and debugging
**Execute a program in a debugger**
```

```

**Create a program using the compilation and linking process**
```

```

**Compile position-independent code using a cross-compiler**
```

```

###6.17 Demonstrate the ability to build a binary from multiple C source files and headers by writing a Makefile using explicit rules

###6.18 Describe how and when bitwise operators are used:
**and (&)**
```

```

**or (|)**
```

```

**xor (^)**
```

```

**bitwise complement (~)**
```

```

**shift left (<<)**
```

```

**shift right (>>)**
```

```

**Add, removing, and testing for single-bit flags**
```

```

**Extracting arbitrary bytes from multi-byte data types**
```

```

###6.19 Demonstrate skill using the C preprocessor

###6.20 Demonstrate skill in accessing environment variables

###6.21 Demonstrate skill in controlling memory:
**With attention given to implementation defined behavior, compare and contast standard memory allocation functions**
```

```

**Describe programming techniques that reduce the occurent of memory leaks**
